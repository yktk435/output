配列名はその排列の戦闘要素へのポインタとして解釈される
配列名がポインタとみなされる

`a[0]`のアドレスは`&a[0]`と同じ

```c++
	int a[5] = {1, 2, 3, 4, 5};
    // pの初期値にはa
    // 式aが&a[0]と解釈されるためpには&a[0]が入る
	int* p = a;		
```


```c++
	for (int i = 0; i < 5; i++)	
		cout << "&a[" << i << "] = " << &a[i] << "  p+" << i << " = " << p + i << '\n';
```

p+iがa[i]を指すのはpがa[0]を指すときのみ

`int *p=&a[2]`とすれば相応の挙動をする

p+iに*を適応すると`*(p+i)`だから要素の値、エイリアスを示す。

pがa[0]を指すなら*pはa[0]そのもの

ポインタなのか、各要素なのかを見極める

```c++
#include <iostream>

using namespace std;

int main()
{
	int a[5] = {1, 2, 3, 4, 5};
    // pはa[0]を指す
	int* p = a;		

	for (int i = 0; i < 5; i++)
		cout << "a[" << i << "] = " << a[i] << "  *(a+" << i << ") = " << *(a + i) << "  "
		     << "p[" << i << "] = " << p[i] << "  *(p+" << i << ") = " << *(p + i) << "\n";

	for (int i = 0; i < 5; i++)
		cout << "&a[" << i << "] = " << &a[i] << "  a+" << i << " = " << a + i << "  "
		     << "&p[" << i << "] = " << &p[i] << "  p+" << i << " = " << p + i << "\n";
}
```

|項目|内容|
|---|---|
|`a[i]`と`*(a)`は同じ|エイリアス|
|`$a[0]`と`a+1`は同じ|ポインタ、アドレス|

p[i]とi[p]はおなじ

a[3]と3[a]は同じ



```c++
#include <iostream>

using namespace std;

int main()
{
	int a[4];
// 全要素に7を代入
	0[a] = a[1] = *(a + 2) = *(3 + a) = 7;		
// a[i]の値を表示
	for (int i = 0; i < 4; i++)
		cout << "a[" << i << "] = " << a[i] << '\n';
}
```
ポインタと整数は加えられる

ポインタ同士は加えれれない

```c++
int a[5];
int b[5];
// エラー
a=b;
```

aは配列へのポインタだが書き換えは不可能

